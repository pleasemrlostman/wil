# 프로세스와 쓰레드

## 프로그램과 프로세스
- **프로그램**
    - 하드디스크와 같은 저장치에 저장된 명령문의 집합체를 말한다. 
    - 애플리케이션이나 앱이라고도 불리고 Windows 운영체제에서는 .exe 파일의 모습을 하고 있다.
    - 프로그램은 컴퓨터 관점에서 하드 디스크 즉 저장 장치만 사용하는 수동적인 존재.

- **프로세스**
    - 프로세스는 실행 중인 프로그램이라 할 수 있다
    - 실행 중인 프로그램이란 하드디스크에 저장된 프로그램이 메모리에 올라갔을 때 실행 중인 프로그램, 즉 프로세스라고 불립니다.
    - 반면 프로세스는 메모리도 사용하고 운영체제의 CPU 스케줄링 알고리즘에 따라서 CPU도 사용하고 필요에 따라 입력과 출력을 하기 때문에 능동적인 존재
- **프로세스의 구조**
    - Code 영역
        - 자신을 실행하는 코드가 저장되어 있음
    - Data 영역
        - 전역 변수와 Static(정적) 변수가 저장되어 있음
    - Stack 영역
        - 지역 변수와 함수 호출을 했을 때 필요한 정보들이 저장
    - Heap 영역
        - 프로그래머가 동적으로 메모리를 할당하는데 쓰임 (런타임시 할당할 수 있는 메모리 공간)
        - C언어에서 `malloc(), 힙 영역에 메모리 공간 할당`, `free(), 할당된 메모리 공간해제` 함수를 호출하면 
- 예시
    -
    ```c
    #include<stdio.h>

    void main()
    {
        int num = 5;
        int num2  = 7;
        int result = num1 + num2
    }
    ```
    > C언어는 컴파일 언어이기 때문에 컴파일 돼야 실행가능하므로 컴파일을 해준다<br>
    컴파일 과정은 먼저 전처리기를 거쳐 매크로로 정의한 숫자를 치환하고 필요한 파일을 불러옵니다.<br>
    전처리기를 거치면 파일의 확장자는 .i 가 됩니다.<br>
    그 다음 컴파일러가 컴파일을 해 줍니다.<br>
    컴파일을 마치면 고수준인 C언어를 저수준인 어셈블리어로 바꿔줍니다.<br>
    컴파일을 거치면 파일의 확장자는 .s가 됩니다.<br>
    이제 어셈블러가 어셈블리어를 기계어로 바꿔줍니다.<br>
    그러면 이 파일은 0과 1로 이루어진  기계어로 구성되고 파일의 확장자는 .o가 된다<br>
    기계어로 구성되어 있기 때문에 파일을 텍스트 에디터로 열어보면 글씨가 깨져서 보인다.<br>
    마지막으로 링커가 링킹을 한다. 여러 가지 라이브러리나 다른 소스코드를 연결한다.<br>
    이렇게 링킹까지 거치면 우리 파일의 확장자는 .exe가 된다<br>
    이제 이 파일을 더블클릭하면 우리의 .exe 파일이 메모리에 올라가게 되고 이렇게 올라간 프로그램은 프로세스라는 새로운 이름으로 불리게 됩니다. 해당 프로세스는 이제부터 운영체제에 의해 관리됩니다.<br>



## 멀티프로그래밍과 멀티 프로세싱
- 유니프로그래밍
    - 메모리에 오직 하나의 프로세스가 올라온 것을 말한다.
- 멀티프로그래밍
    - 메모리에 여러개의 프로세스가 올라 온 것.
- 멀티프로세싱
    - 유니프로그래밍과 멀티프로그래밍을 메모리의 관점으로 정의했다면 멀티프로세싱은 CPU관점으로 정의한 것
    - 멀티프로세싱은 CPU가 여러 개의 프로세스를 처리하는 것을 말한다.

오늘날의 OS는 멀티프로그래밍과 멀티프로세싱 두 개가 공존한다.<br>
메모리에는 여러 개의 프로세스가 올라오는 멀티프로그래밍이 있고 시분할 처리로 CPU가 각각의 프로세스를 짧은 시간 동안 교대로 실행하는 멀티프로세싱이 있다.<br>

과거에는 메모리의 크기가 작아서 멀티프로그래밍이 불가능했다. 이 때는 유니프로그래밍을 하면서 멀티프로세싱을 이용했다.<br>
메모리에 프로세스를 올려서 CPU로 처리를하고 이 프로세스를 다른 저장장치에 저장합니다.<br>
그리고 다른 저장장치에있던 프로세스를 메모리에 올려서 CPU로 처리하는 멀티프로세싱 기법을 사용했다.<br>
이 때 메모리에 있는 데이터를 다른 저장장치로 보내고 다른 저장장치에서 메모리에올리는 것을 스와핑이라고 한다.

## PCB (Process Control Block)
프로그램이 메모리에 올라가서 실행중인 상태를 **프로세스**라고 말한다.<br>
운영체제는 여러개의 프로세스를 전부 다 관리하고 공평하게 실행시켜야한다.<br>

프로세스가 만들어지면 운영체제는 해당 프로세스의 정보를 가지고있는 PCB를 만들고 저장한다. PCB는 연결리스트 자료구조로 저장된다.<br>
운영체제는 프로세스가 종료되면 연결리스트에서 해당 프로세스의 PCB를 제거한다.

-  
    |PCB구조||
    |---|---|
    |포인터|부모와 자식 프로세스에 대한 포인터와 할당된 자원에 대한 포인터, 플호세스의 한 상태에서 다른 상태로 전환될 때 저장하는 포인터|
    |프로세스 상태|현재 프로세스의 다섯가지 상태 (생성, 준비, 실행, 대기, 완료)|
    |프로세스 ID|프로세스를 식별하기 위한 숫자|
    |프로그램 카운터|다음에 실행될 명령어의 주소를 포함하는 프로그램 카운터를 저장, 다른 프로세스를 실행했다 돌아 오기 때문에 필요| 
    |레지스터 정보|프로세스가 실행될 때 사용했던 레지스터 값들이 저장 (프로그램 카운터와 마찬가지로 이전 값을 사용하기 위해 저장)|
    |메모리 관련 정보|메모리 관련 정보에는 프로세스가 메모리에 있는 위치 정보, 메모리 침범을 막기위한 경계레지스터 값 등이 저장|
    |CPU 스케줄링 정보|CPU 스케줄링에 필요한 우선순위, 최종 실행시간, CPU 점유시간등이 저장|

## 프로세스 상태
사용자가 프로그램을 실행시키면 메모리에 올라가면서 프로세스가 생성된다. 오늘날의 운영체제에는 동시에 수많은 프로세스가 실행된다.<br>
시분할 시스템을 사용하는 운영체제는 여러개의 프로세스를 돌아가면서 실행한다. CPU가 여러개의 프로세스를 동시에 실행한다는 말이 아니라 한 순간에는 하나의 프로세스밖에 처리하지 못한다는 것 이다. 다만 속도가 매우 빨라서 사람이 보기에는 동시에 실행되는 것 처럼 보인다.

프로세스는 시분할 처리를 위한 다섯가지 상태를 가지고 있다.
- 생성상태
    - PCB를 생성하고 메모리에 프로그램 적재를 요청한 상태이다.
    - 메모리에 프로그램 적재를 승인받으면 준비상태로 넘어간다.
- 준비상태
    - 준비상태는 CPU를 사용하기 위해 기다리고 있는 상태
    - 준비상태에 있는 프로세스는 이후에 배울 CPU스케줄러에 의해 CPU가 할당된다.
    - 대부분의 프로세스는 이 준비상태에 있다 
- 실행상태
    - 준비상태에 있는 프로세스가 CPU스케줄러에 의해 CPU를 할당받아 실행되는 상태
    - 실행상태에 있는 프로세스의 수는 CPU의 개수만큼이다
    - CPU가 한 개라면 실행상태의 프로세스는 최대 한 개이다.
    - 실행상태에 있는 프로세스도 CPU를 무한정 쓸 수 있는 것이 아니라 부여된 시간만큼만 사용할 수 있다.
    - CPU 스케줄러는 부여된 시간을 초과하면 할당된 CPU를 강제로 빼았는다.
    - 그럼 프로세스는 다시 준비상태로 돌아간다.
- 대기상태
    - 프로세스가 입출력 요청을하면 입출력이 완료될 때 까지 기다리는 상태
    - CPU는 굉장히 빠른 장치지만 입출력 작업은 상당히 느린작업이다
    - 특정 프로세스가 입출력 요청을하면 입출력이 완료될 때 까지 CPU를 기다리게 하는건 굉장히 비효율적이다
    - 대신 입출력 요청을 한 프로세스를 대기상태로 두고 다른 프로세스에게 CPU를 할당한다.
    - 그러다가 시간이 지나서 입출력 작업이 완료되면 대기상태에 있던 프로세스에게 CPU할당 기회를준다
    - 이렇게하면 CPU에게 쉬는 시간을 주지않고 일을 시킬 수 있다.
- 완료상태
    - 프로세스가 종료된 상태
    - 프로세스가 사용했던 데이터를 메모리에서 제거하고 생성된 PCB도 제거한다.
## 컨텍스트 스위칭

## 프로세스 생성과 종료

## 쓰레드