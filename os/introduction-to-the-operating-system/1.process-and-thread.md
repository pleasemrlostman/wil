# 프로세스와 쓰레드

## 프로그램과 프로세스
- **프로그램**
    - 하드디스크와 같은 저장치에 저장된 명령문의 집합체를 말한다. 
    - 애플리케이션이나 앱이라고도 불리고 Windows 운영체제에서는 .exe 파일의 모습을 하고 있다.
    - 프로그램은 컴퓨터 관점에서 하드 디스크 즉 저장 장치만 사용하는 수동적인 존재.

- **프로세스**
    - 프로세스는 실행 중인 프로그램이라 할 수 있다
    - 실행 중인 프로그램이란 하드디스크에 저장된 프로그램이 메모리에 올라갔을 때 실행 중인 프로그램, 즉 프로세스라고 불립니다.
    - 반면 프로세스는 메모리도 사용하고 운영체제의 CPU 스케줄링 알고리즘에 따라서 CPU도 사용하고 필요에 따라 입력과 출력을 하기 때문에 능동적인 존재
- **프로세스의 구조**
    - Code 영역
        - 자신을 실행하는 코드가 저장되어 있음
    - Data 영역
        - 전역 변수와 Static(정적) 변수가 저장되어 있음
    - Stack 영역
        - 지역 변수와 함수 호출을 했을 때 필요한 정보들이 저장
    - Heap 영역
        - 프로그래머가 동적으로 메모리를 할당하는데 쓰임 (런타임시 할당할 수 있는 메모리 공간)
        - C언어에서 `malloc(), 힙 영역에 메모리 공간 할당`, `free(), 할당된 메모리 공간해제` 함수를 호출하면 
- 예시
    -
    ```c
    #include<stdio.h>

    void main()
    {
        int num = 5;
        int num2  = 7;
        int result = num1 + num2
    }
    ```
    > C언어는 컴파일 언어이기 때문에 컴파일 돼야 실행가능하므로 컴파일을 해준다<br>
    > 컴파일 과정은 먼저 전처리기를 거쳐 매크로로 정의한 숫자를 치환하고 필요한 파일을 불러옵니다.<br>
    >
    > 전처리기를 거치면 파일의 확장자는 .i 가 됩니다.<br>
    > 그 다음 컴파일러가 컴파일을 해 줍니다.<br>
    >
    > 컴파일을 마치면 고수준인 C언어를 저수준인 어셈블리어로 바꿔줍니다.<br>
    > 컴파일을 거치면 파일의 확장자는 .s가 됩니다.<br>
    >
    > 이제 어셈블러가 어셈블리어를 기계어로 바꿔줍니다.<br>
    > 그러면 이 파일은 0과 1로 이루어진  기계어로 구성되고 파일의 확장자는 .o가 된다<br>
    >
    > 기계어로 구성되어 있기 때문에 파일을 텍스트 에디터로 열어보면 글씨가 깨져서 보인다.<br>
    > 마지막으로 링커가 링킹을 한다. 여러 가지 라이브러리나 다른 소스코드를 연결한다.<br>
    > 이렇게 링킹까지 거치면 우리 파일의 확장자는 .exe가 된다<br>
    >
    > 이제 이 파일을 더블클릭하면 우리의 .exe 파일이 메모리에 올라가게 되고 이렇게 올라간 프로그램은 프로세스라는 새로운 이름으로 > 불리게 됩니다. 해당 프로세스는 이제부터 운영체제에 의해 관리됩니다.<br>



## 멀티프로그래밍과 멀티 프로세싱
- 유니프로그래밍
    - 메모리에 오직 하나의 프로세스가 올라온 것을 말한다.
- 멀티프로그래밍
    - 메모리에 여러개의 프로세스가 올라 온 것.
- 멀티프로세싱
    - 유니프로그래밍과 멀티프로그래밍을 메모리의 관점으로 정의했다면 멀티프로세싱은 CPU관점으로 정의한 것
    - 멀티프로세싱은 CPU가 여러 개의 프로세스를 처리하는 것을 말한다.

오늘날의 OS는 멀티프로그래밍과 멀티프로세싱 두 개가 공존한다.<br>
메모리에는 여러 개의 프로세스가 올라오는 멀티프로그래밍이 있고 시분할 처리로 CPU가 각각의 프로세스를 짧은 시간 동안 교대로 실행하는 멀티프로세싱이 있다.<br>

과거에는 메모리의 크기가 작아서 멀티프로그래밍이 불가능했다. 이 때는 유니프로그래밍을 하면서 멀티프로세싱을 이용했다.<br>
메모리에 프로세스를 올려서 CPU로 처리를하고 이 프로세스를 다른 저장장치에 저장합니다.<br>
그리고 다른 저장장치에있던 프로세스를 메모리에 올려서 CPU로 처리하는 멀티프로세싱 기법을 사용했다.<br>
이 때 메모리에 있는 데이터를 다른 저장장치로 보내고 다른 저장장치에서 메모리에올리는 것을 스와핑이라고 한다.

## PCB (Process Control Block)
프로그램이 메모리에 올라가서 실행중인 상태를 **프로세스**라고 말한다.<br>
운영체제는 여러개의 프로세스를 전부 다 관리하고 공평하게 실행시켜야한다.<br>

프로세스가 만들어지면 운영체제는 해당 프로세스의 정보를 가지고있는 PCB를 만들고 저장한다. PCB는 연결리스트 자료구조로 저장된다.<br>
운영체제는 프로세스가 종료되면 연결리스트에서 해당 프로세스의 PCB를 제거한다.

-  
    |PCB구조||
    |---|---|
    |포인터|부모와 자식 프로세스에 대한 포인터와 할당된 자원에 대한 포인터, 플호세스의 한 상태에서 다른 상태로 전환될 때 저장하는 포인터|
    |프로세스 상태|현재 프로세스의 다섯가지 상태 (생성, 준비, 실행, 대기, 완료)|
    |프로세스 ID|프로세스를 식별하기 위한 숫자|
    |프로그램 카운터|다음에 실행될 명령어의 주소를 포함하는 프로그램 카운터를 저장, 다른 프로세스를 실행했다 돌아 오기 때문에 필요| 
    |레지스터 정보|프로세스가 실행될 때 사용했던 레지스터 값들이 저장 (프로그램 카운터와 마찬가지로 이전 값을 사용하기 위해 저장)|
    |메모리 관련 정보|메모리 관련 정보에는 프로세스가 메모리에 있는 위치 정보, 메모리 침범을 막기위한 경계레지스터 값 등이 저장|
    |CPU 스케줄링 정보|CPU 스케줄링에 필요한 우선순위, 최종 실행시간, CPU 점유시간등이 저장|

## 프로세스 상태
사용자가 프로그램을 실행시키면 메모리에 올라가면서 프로세스가 생성된다. 오늘날의 운영체제에는 동시에 수많은 프로세스가 실행된다.<br>
시분할 시스템을 사용하는 운영체제는 여러개의 프로세스를 돌아가면서 실행한다. CPU가 여러개의 프로세스를 동시에 실행한다는 말이 아니라 한 순간에는 하나의 프로세스밖에 처리하지 못한다는 것 이다. 다만 속도가 매우 빨라서 사람이 보기에는 동시에 실행되는 것 처럼 보인다.

프로세스는 시분할 처리를 위한 다섯가지 상태를 가지고 있다.
- 생성상태
    - PCB를 생성하고 메모리에 프로그램 적재를 요청한 상태이다.
    - 메모리에 프로그램 적재를 승인받으면 준비상태로 넘어간다.
- 준비상태
    - 준비상태는 CPU를 사용하기 위해 기다리고 있는 상태
    - 준비상태에 있는 프로세스는 이후에 배울 CPU스케줄러에 의해 CPU가 할당된다.
    - 대부분의 프로세스는 이 준비상태에 있다 
- 실행상태
    - 준비상태에 있는 프로세스가 CPU스케줄러에 의해 CPU를 할당받아 실행되는 상태
    - 실행상태에 있는 프로세스의 수는 CPU의 개수만큼이다
    - CPU가 한 개라면 실행상태의 프로세스는 최대 한 개이다.
    - 실행상태에 있는 프로세스도 CPU를 무한정 쓸 수 있는 것이 아니라 부여된 시간만큼만 사용할 수 있다.
    - CPU 스케줄러는 부여된 시간을 초과하면 할당된 CPU를 강제로 빼았는다.
    - 그럼 프로세스는 다시 준비상태로 돌아간다.
- 대기상태
    - 프로세스가 입출력 요청을하면 입출력이 완료될 때 까지 기다리는 상태
    - CPU는 굉장히 빠른 장치지만 입출력 작업은 상당히 느린작업이다
    - 특정 프로세스가 입출력 요청을하면 입출력이 완료될 때 까지 CPU를 기다리게 하는건 굉장히 비효율적이다
    - 대신 입출력 요청을 한 프로세스를 대기상태로 두고 다른 프로세스에게 CPU를 할당한다.
    - 그러다가 시간이 지나서 입출력 작업이 완료되면 대기상태에 있던 프로세스에게 CPU할당 기회를준다
    - 이렇게하면 CPU에게 쉬는 시간을 주지않고 일을 시킬 수 있다.
- 완료상태
    - 프로세스가 종료된 상태
    - 프로세스가 사용했던 데이터를 메모리에서 제거하고 생성된 PCB도 제거한다.
## 컨텍스트 스위칭
컨텍스트 스위칭은 프로세스를 실행하는중에 다른 프로세스를 실행하기위해 실행중인 프로세스의 상태를 저장하고 다른 프로세스의 상태값으로 교체하는 작업

컨텍스트 스위칭이 일어 날 때 PCB의 내용이 변경된다.

실행중인 프로세스의 작업내용을 PCB에 저장하고 실행될 기존 프로세스의 PCB 내용대로 다시 CPU가 다시 세팅됩니다.

컨텍스트 스위칭이 일어날 때 PCB에 변경하는 값들로는 프로세스 상태, 다음 실행할 명령어의 주소를 담고있는 프로그램 카운터, 각종 레지스터값 등이 있다. 프로세스 두 개가 컨텍스트 스위칭을 하는 상황을 살펴보자

프로세스 A가 실행을 하는데 CPU 점유시간을 초과했다. 운영체제는 프로세스 A가 CPU를 너무 오래 사용했다고 판단하고 인터럽트를 발생시킵니다. 

프로세스 A는 하던일을 멈추고 그리고 나중에 현재 상태에서 시작되어야 하기 때문에 현재 CPU의 레지스터 값 등을 PCB A에 저장합니다. 이제 PCB B를 참조해서 이전 프로세스 B의 상태로 CPU 레지스터값을 설정합니다. 

여기에는 다음 실행할 명령어의 주소를 가지고 있는 프로그램 카운터(PC)를 가지고 있기 때문에 바로 프로세스 B의 명령어를 실행할 수 있습니다. 

프로세스 B가 점유시간동안 CPU를 사용하다가 점유시간이 다되면 운영체제는 다시 인터럽트를 발생시킵니다. 그리고 프로세스 B의 현재상태를 PCB B에 저장하고 PCB A에서 프로세스 A의 상태를 가져오고 다시 프로세스 A를 실행시킵니다.

이런식으로 메모리에 있는 모든 프로세스들은 컨텍스트 스위칭을 합니다. 컨텍스트 스위칭이 발생하는 이유는 다양하다. CPU 점유시간이 다 되거나 I/O 요청이 있거나 다룬 종류의 인터럽트가 있을 때 발생합니다.


## 프로세스 생성과 종료
일반적으로 프로세스가 생성될 때는 다음과 같은 방법으로 생성된다.

만약 내가 .exe 파일을 더블클릭으로 실행하면 운영체제는 해당 프로개름의 코드영역과 데이터영역을 메모리에 로드하고 빈 스택과 빈 힙을 만들어 공간을 확보한다.

이제 이 프로세스를 관리하기 위한 PCB를 만들어서 값을 초기화해준다.

지금 설명한 프로세스 생성과정은 운영체제가 부팅되고 0번 프로세스가 생성될 때 딱 한번 실행된다.

이제 나머지 모든 프로세스는 새로 생성하지않고 0번 프로세스를 복사해서 쓰게된다.

복사는 `fork()` 함수를 이용합니다. 새로 생성하는 것 보다 복사를 하는게 더 빠르기 때문이다. 0번 프로세스를 복사해서 생성된 프로세스는 자식 프로세스라고 하고 이 자식 프로세스의 입장에서 0번 프로세스는 부모 프로세스가 됩니다.

자식 프로세스는 부모 프로세스의 코드영역, 데이터영역, 스택영역과 PCB의 내용을 전부 복사합니다.

여기서 드는 의문은 0번 프로세스의 코드와 데이터를 모두 복사해서 실행하면 0번 프로세스가 똑같이 실행되는거라고 의문을 가질 수 있다.

정답은 맞다 0번 프로세스를 그대로 복사하니 당연한 결과이다. 자기가 원하는 코드를 실행시키는 방법은 `exec()` 함수를 이용하는 것 이다. `fork()` 함수로 프로세스를 복사후 `exec()` 함수를 실행시키면 부모를 복사한 자식 프로세스 코드와 데이터 영역을 원하는 값으로 덮어쓰게 됩니다. 그럼 이 때부터 자식프로세스는 부모 프로세스와 완전히 다르게 동작한다.

코드를 보면서 자세히 알아보자

```c
#include <stdio.h>
#include <unistd.h>

int main()
{
    int pid;
    pid = fork(); //부모 프로세스는 pid = 1, 자식 프로세스는 pid = 0

    if(pid == 0)
    {
        exclp("InternetBrowser", "0", NULL);
        exit(0);
    }
    else
    {
        wait(NULL);
        printf("인터넷 브라우저 닫힘");
        exit(0);
    }
}

```

`fork()` 함수를 호출하고 그럼 운영체제는 이 프로세스와 동일한 프로세스를 복사하고 `fork()` 함수의 반환값으로 부모 프로세스에게는 0이 아닌 값을 자식 프로세스에게는 0을 반환합니다. 이제 이 두개의 프로세스는 CPU 스케줄링에 따라 실행되는데 어떤 프로세스가 먼저 실행될지는 운영체제의 결정에 따른다.

부모 프로세스가 먼저 실행된다고 가정해보자 부모 프로세스는 `fork()` 함수 반환값으로 1을 받았다. 그럼 if문이 거짓이 되어 else 문을 실행한다. 그러면 `wait()` 함수를 호출한다 해당 함수는 자식 프로스세에게서 `exit()` 신호가 올 때 까지 기다리는 시스템 함수이다.

컨텍스트 스위칭을 거쳐 부모프로세스에게 CPU가 할당되어도 자식 프로세스의 `exit()` 신호가 오기 전 까지는 다른 코드를 실행시키지 않는다. 이제 CPU 스케줄링으로 자식 프로세스가 실행된 상태입니다. 자식 프로세스는 `fork()` 함수의 반환값으로 0을 받았다.

그럼 if문이 참이되어 if문 안을 실행시키면 `execlp()` 함수로 InternetBrowser 프로그램을 실행시킨다. 그러면 InternetBrowser 에서 코드와 데이터영역을 가져와서 자식 프로세스를 덮어쓰게 된다.

이제부터 완전히 다른 코드가 실행된다. InternetBrowser를 사용하다가 종료가되면 `exit()` 함수를 호출하고 프로세스의 종류를 알린다.
이제 CPU스케줄링으로 다시 부모 프로세스가 실행된 상황이다. `wait()` 함수로 자식 프로세스의 종료를 기달리고 있었는데 자식 프로세스가 종료됐다. 부모 프로세스는 자식 프로세스를 완전히 종료시킨다. 그리고 `exit()` 함수로 프로세스 종료를 알린다.

예제를 통해 `exit()` 함수는 자식 프로세스가 부모 프로세스에게 정상종료를 알리는 함수이다. 부모프로세스는 자식 프로세스의 Exit Status를 읽고 자식 프로세스를 정리한다.

만약 부모프로세스가 자식 프로세스보다 먼저 종료되거나 자식 프로세스가 비정상적으로 종료돼 `exit()` 신호를 주지못해서  Exit Status를 읽지 못해 메모리에 계속 살아있는 상태를 **좀비 프로세스** 라고 부른다.

컴퓨터를 오래켜두면 느려지는 현상이 발생하곤하는데 이는 여러 프로세스가 메모리에 올라온 것도 있고 좀비 프로세스가 많아져서 메모리를 차지하는 경우가 있다. 컴퓨터를 껏다가 키면 메모리가 초기화되기 때문에 다시 빨라진다.

## 쓰레드

운영체제가 작업을 처리하는 단위는 프로세스이다. 사용자가 운영체제에게 작업을 요구하면 그만큼 프로세스의 수가 늘어난다.

프로세스를 생성하면 PCB가 생성되고 메모리에 코드, 데이터, 스택, 힙영역을 만들어줘야한다. 프로세스의 수가 많아지면 프로세스의 수 만큼 PCB, 코드, 데이터, 스택, 힙영역도 만들어줘야 하기 때문에 너무 무거워진다.

예를들어 보자, 웹브라우저를 실행시키면 프로세스 1개가 생성된다. 여기서 웹브라우저의 탭을 1개 더 추가하면 기존 프로세스를 복사해서 총 2개 프로세스가 존재하게된다. 만약 탭을 20개 추가한다면 프로세스 복사가 20번 일어나고 PCB와 코드, 데이터, 스택, 힙, 영역이 20개 생성된다.

결국 웹브라우저가 메모리를 너무 많이 차지하게 된다.