# CPU스케줄링

## CPU스케줄링 개요
프로세스는 CPU를 차지하기 위해 운영체제의 명령을 기다리고 있다.<br>
운영체제는 모든 프로세스에게 CPU를 할당/해제 하는데 이를 **CPU 스케줄링**이라고 한다.<br>
CPU스케줄링에서 스케줄러(운영체제)가 고려해야 할 사항은 두 가지가 있다

- 어떤 프로세스에게 CPU 리소스를 줘야하는가?
    - 메모리에는 수 많은 프로세스들이 있는데 여기서 **어떤 프로세스에게 CPU 사용권을 줘야하는가**하는 문제이다.
-  CPU를 할당받은 프로세스가 얼마의 시간동안 CPU를 사용해야하는가?
    - 오늘날은 시분할 처리방식으로 여러 프로세스에게 짧은 시간동안 돌아가면서 CPU를 할당한다
    - 예를 들어 프로세스 A에게 1초동안 CPU 이용권을 주고 그 다음 CPU를 뺏어 프로세스 B에게 CPU 이용권을 주는 방식이다

이 두 가지 사항이 컴퓨터 성능에 굉장히 큰 영향을 미친다.
CPU를 할당받아 실행하는 작업을 **CPU Burst**라고 부르고 입출력 작업을 **I/O Burst**라고 부른다.

## 다중큐
프로세스가 대기하고있는 준비상태와 대기상태는 큐(Queue)라는 자료구조로 관리된다
큐(Queue) 자료구조는 우리가 마트 계산대에 줄을 서는 것과 같이 먼저 온 사람이 가장 먼저 처리를 받고 나중에 온 사람은 나중에 처리받는 구조이다. 먼저 들어온게 나중에 처리받고 나중에 들어온게 먼저 처리받는 스택이랑은 상반된다.

프로세스가 실행상태에서 준비상태로 돌아갈 때 운영체제는 해당 프로세스의 우선순위를 보고 그에맞는 **준비 큐**에 넣습니다.<br>
CPU스케줄러는 **준비상태의 다중큐**에 들어있는 프로세스들 중에 적당한 프로세스를 선택해서 실행상태로 전환시킵니다.

프로세스가 실행상태에서 I/O 요청을 받아 대기상태로 오게되면 I/O 작업 종류에 따라서 분류된 큐에 들어가게됩니다. 예를들면 하드디스크 작업은 **HDD 큐**에 들어가고 하드디스크 작업이 완료되어 인터럽트가 발생되면 **HDD 큐**를 뒤져서 다시 꺼내갑니다.

지금까지 큐에 프로세스가 들어간다고 했는데 정확히는 프로세스의 정보를 가지고 있는 PCB가 들어간다.

프로세스 정보를 담고있는 PCB는 준비상태의 다중큐에 들어가서 실행되기를 기다리고 있고 CPU스케줄러에 의해 실행상태로 전환된다. 이 때 CPU스케줄러는 준비상태의 다중큐를 참조해서 어떤 프로세스를 실행시킬지 결정한다.

실행중인 프로세스에서 I/O 작업이 발생하면 해당 I/O 작업의 종류별로 나뉜 큐에 들어가고 CPU스케줄러는 이를 참조해 스케줄링한다.

## 스케줄링 목표
- 리소스 사용률
    - CPU 사용률을 높이는 것을 목표로 할 수도 있고 I/O 디바이스의 사용률을 높이는 것을 목표로 할 수도 있다.
- 오버헤드 최소화
    - 스케줄링을 하기 위한 계산이 너무 복잡하거나 컨택스트 스위칭을 너무 자주하면 배보다 배꼽이 더 커지는 상황이 나온다 스케줄러는 이런 오버헤드를 최소화 하는 것을 목표로한다. 
- 공평성
    - 모든 프로세스에게 공평하게 CPU가 할당되어야 한다. 그러나 프로세스의 목적에 따라 그 공평성이 달라 질 수 있음
- 처리량
    - 같은 시간내에 더 많은 처리를 할 수 있는 방법을 목표로한다.
- 대기시간
    - 작업을 요청하고 실제 작업이 이루어지기 전까지 대기하는 시간이 짧은 것을 목표로 한다.
- 응답시간
    -  대화형 시스템에서 사용자의 요청이 얼마나 빨리 반응하는지가 중요하기 때문에 응답시간이 짧은 것을 목표로 한다.

지금 말한 목표들을 모두 최고의 수준으로 유지하는 것은 어렵다. 그 이유는 목표간에 서로 상반되는 상황이 있기 때문이다.<br>
예를들면 처리량을 높이기 위해서는 하나의 프로세스에 CPU를 오래 할당해야한다. 반면 응답시간을 줄이기 위해서는 여러 프로세스에 골고루 CPU 를 할당해야하는데 서로 상반되기 때문에 처리량과 응답시간의 목표를 같이 달성할 수 없다.

이 때는 사용자가 사용하는 시스템에 따라서 목표를 다르게 설정한다.

터치스크린과 같이 사용자에게 빠른 응답이 필요한 경우는 응답시간이 짧도록 초점을 맞추고 과학 계산같은 경우는 처리량이 높도록 초점을 맞춘다.

일반 사용자의 경우 특별한 목표가 없다면 어느 한쪽에 치우치지 않도록 밸런스를 유지하는게 중요하다.

## CPU스케줄링 알고리즘

운영체제 설계자들이 생각한 스케줄링은 처음에는 복잡하지 않았다. 

스케줄링의 성능은 **평균 대기 시간** 으로 평가한다. **평균 대기 시간**은 프로세스가 여러개가 실행될 때 이 프로세스들 모두가 실행되기까지 대기시간의 평균을 말한다. 

### FIFO
먼저 들어온 작업이 먼저 나간다는 뜻으로 스케줄링 큐에 들어온 순서대로 CPU를 할당받는 방식<br>
이 방식은 먼저 들어온 프로세스가 완전히 끝나야만 다음 프로세스가 실행될 수 있습니다.
- 장점
    - 단순하고 직관적
- 단점
    - 한 프로세스가 완전히 끝나야 다음 프로세스가 시작되기 때문에 실행시간이 짧고 늦게 도착한 프로세스가 실행기간이 길고 빨리 도착한 프로세스의 작업을 기다려야 한다는 것이다. 또한 I/O 작업이 있다고 하면 CPU는 I/O 작업이 끝날 때 까지 쉬고 있기 때문에 CPU 사용률이 떨어지게 된다.
    - FIFO 알고리즘은 프로세스의 Burst Time에 따라 성능의 차이가 심하게나기 때문에 현대 운영체제에서 잘 쓰이지 않고 일괄처리시스템에 쓰인다.

 

### SJF
### RR
### MLFQ