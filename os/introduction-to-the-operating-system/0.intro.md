# 운영체제 들어가기

## 운영체제 개요

요즘에는 운영체제가 쓰이는 곳이 굉장히 많다. 개인용 컴퓨터에는 Windows나 MaccOS가 많이 쓰이고 대형 컴퓨터나 서버용으로는 유닉스나 리눅스가 많이쓰인다. 스마트폰과 태블릿에는 안드로이드와 iOS 운영체제가 쓰이고 내비게이션, 스마트 워치, 냉장고, 세탁기 등에 들어가는 임베디드 운영체제가 있다.<br>

여기서 의문은 **컴퓨터는 운영체제가 있어야 동작하는가?** 정답은 **없어도 동작한다**이다. 하지만 운영체제가 없으면 처음 설계한 그대로만 동작할 뿐 다른 기능을 추가할 수가 없다. 예전에 사용하던 유선 전화기는 통화기능만 가능하고 별다른 기능이 없지만 운영체제가 있는 스마트폰은 애플리케이션을 설치해 기능을 추가할 수 있다.

### 운영체제가 하는 일

1. 프로세스 관리
    - 내가 인터넷을 하고 있으면서 노래도 듣고 게임도 할 수 있는 이유는 운영체제가 프로세스를 관리해주기 때문
2. 메모리 관리
    - 모든 프로그램은 메모리에 올라와서 동작한다. 오늘날 운영체제는 여러 프로그램을 동시에 실행시키기 때문에 여러 프로그램을 메모리에서 관리하고 있다.
3. 하드웨어 관리
    - 운영체제는 사용자의 하드웨어에 대한 직접적인 접근을 막는다. 내가 하드디스크에 특정한 데이터를 저장할 때 하드디스크의 특정 영역에 바로 저장하지 못하게 하고 운영체제가 판단해서 적절한 위치에 저장한다. 그 이유는 하드디스크 영역에 다른 데이터가 있을 수도 있고 사용자가 악의적으로 공격할 수 있기 때문이다.
4. 파일 시스템 관리
    - 하드디스크에 많은 파일들의 효율적인 저장 및 관리를 수행한다.



## 운영체제의 역사
운영 체제의 역사를 알아보면 오늘날의 운영체제가 왜 이렇게 복잡해졌는지 어느 정도 이해가 된다.

- 1940년도
    - 애니악은 1943년 미군지휘하에 펜실베니아 대학교에서 개발된 컴퓨터
        - 최초의 목적은 미사일 탄도계산
        - 세계에서 가장 큰 스케일의 전자디지털 계산기 (30톤)
        - 특정 명령에 맞는 스위치와 배선을 연결해서 프로그래밍 했다.
        - 문제가 발생하면 종이에 작업을 해서 테스트를 마친 후 종이를 보고 스위치와 배선을 연결함
        - 큰 기계에 스위치와 배선을 이용하기 때문에 인력도 많이 필요하고 시간도 오래걸렸음
    - 애니악을 설계한 사람들은 하드웨어 비용이 굉장히 비싸기 때문에 CPU를 효율적으로 사용하는 방법에 대해 고민하기 시작함
        - 인건비는 저렴했기 때문에 고려 대상은 아니었다.
- 1950년도 초반
    - 진공관과 전선으로 만들어진 논리회로를 아주 작은 크기로 만든 직접회로 (IC)가 개발됨
        - 이로써 현대적인 컴퓨터의 모습을 갖추게 됐다.
    - 이 때는 CPU와 메모리가 있었지만 키보드와 모니터는 없었다.
        - 대신 펀치카드를 이용해서 프로그래밍을 했다.
            - 기존에 사용했던 스위치와 배선작업보다 훨씬 편리해짐
- 1950년도 후반
    - 이전에는 프로그래머가 펀치 카드를 이용해서 프로그램을 작성하면 오퍼레이터가 직접 컴퓨터에 카드를 넣고 결과가 나오면 프로그래머에게 전달하는 방식
        - 이러헌 방식에선 컴퓨터가 처리하는 속도보다 오퍼레이터가 카드를 넣고 전달하는 과정이 더 오래걸림 즉 오퍼레이터의 오버헤드가 컸다
    - 그래서 프로그래머가 펀치 카드를 가져오면 여러 개를 한번에 컴퓨터에 전달해주고 컴퓨터는 여러 개의 프로그램을 순서대로 실행해서 결과도 한번에 확인할 수 있도록 개발했는데 이를 **싱글스트림 배치시스템** 이라고 부른다.
        - 이러면 여러개의 작업을 하는데 작업이 끝날 때 마다 일일이 오퍼레이터가 결과를 꺼내고 다시 다른 프로그램을 실행시키는 비효율적인 과정이 없어져 CPU의 사용률이 올라갔다.
    - 컴퓨터 시스템 개발자들은 CPU의 사용성을 더 높이기 위해서 고민했다.
    - 당시에는 입출력 작업을 하는 동안에는 CPU를 사용할 수 없었는데 입출력을 담당하는 **I/O 디바이스 컨트롤러**를 만들어 입출력 중에도 CPU가 계산할 수 있도록 만들었다.
        - **I/O 디바이스 컨트롤러**는 입출력 작업이 끝나면 CPU에게 인터럽트 신호를 주고 인터럽트를 받은 CPU는 다시 처리하는 식으로 발전됐다.
    - 여기서 발생하는 문제는 CPU와 입출력을 분리했는데 입출력에도 CPU를 기다려야 하는 작업이 있었다.
        - 예를들어 어떤 작업에서 입력을하고 입력을 처리하는 작업일 때 입력이 전부 완료되어야만 처리할 수 있기 때문에 어쩔 수 없이 기다리게 된다. 그러나 출력 같은 경우 CPU가 종속적이지 않기 때문에 기다리지 않는다. 이 경우 출력은 **I/O 디바이스 컨트롤러**를 이용해서 CPU와 분리가 가능하지만 입력인 경우에는 어쩔 수 없이 기다려야 하기 때문에 CPU 사용률이 떨어지게 된다. **싱글스트림 배치시스템**은 이러한 문제점이 있다.

- 1960년도
    - 이때는 **싱글스트림 배치시스템**의 한계를 극복했다. 프로그램을 하나씩 실행하는 것이 아니라 메모리에 여러 프로그램을 올려놓고 시간을 나누어서 A에 0.1 B에 0.1 C에 0.1씩 빠르게 돌아가면서 실행시킨다. 매우 빠르게 번갈아 가면서 실행하기 때문에 사용자에게는 전부 동시에 실행되는 것처럼 보인다. 이러한 시스템을 **시분할 시스템** (시간을 분할해서 사용하는 시스템) 이라고 한다.
    - 이러한 방법을 사용하게 되니 A의 입력작업이 실행되어 CPU가 기다릴 때 B와 C가 실행되기 떄문에 CPU의 사용률이 또 다시 증가했다.
    - 프로그램을 동시에 여러 개 실행할 수 있으니 여러 사용자가 한 번에 사용 가능하게 됐다.
    - 컴퓨터는 비쌌기 때문에 하나의 컴퓨터를 두고 터미널이라는 단말기를 통해 여러 사용자들이 여러 터미널로 하나의 컴퓨터에 접근해서 사용했다.
    - 사용자는 컴퓨터를 혼자 사용하는 것 같아서 컴퓨터에 개인이 필요한 문서와 같은 개인정보를 젖아하기 시작했고 이 때문에 파일시스템이 등장했다.
    - AT&T벨 연구소에서 C언어로 유닉스 운영체제를 개발했는데 이 운영체제가 조금 전에 말한 프로그램을 동시에 여러 개 실행시키는 **멀티 프로그래밍**과 여러 사용자를 지원하는 **다중 사용자**와 **파일 시스템**을 구현한 운영체제였습니다.
    - 또 다른 의미로 1960년대는 혼돈의 시대였다.
        - 여러 프로그램을 동시에 실행시키려니 생각지도 못한 문제들이 발생했다.
            1. 메모리에 여러 프로그램이 올라와서 작업을 실행하기 때문에 메모리 침범 이슈가 발생
                - A 프로그램이 B 영역에 침범하거나 혹은 OS영역에 침범해 치명적인 에러가 발생할 수 있음
            2. 기존에는 프로그램을 작성할 때 메모리에는 프로그램이 하나가 있기 때문에 메모리 주소를 프로그램이 하나라고 가정하고 프로그래밍을 했는데 이제는 여러개의 메모리가 올라가니 자기가 어느 메모리 위치에서 실행되는지 모르는 상황이 발생
        - 이러한 문제를 해결하기 위해 **베이스 레지스터**라는 것을 추가해서 프로그램 시작 주소를 저장하고 모든 프로그램은 0번지에서 실행한다고 가정하게 된다. 
        - 이렇게 CPU의 사용률을 늘리고 효율성을 높이면서 발생하는 문제를 직면하다보니 미국의 대학들은 이것이 굉장히 복잡하고 중요한 문제라는것을 깨닫고 하나의 학문으로 자리를 잡게되었다.

- 1970년도 이후
    - 1970년대는 개인용 컴퓨터의 시대가 시작됐다.
    - 이전에는 하드웨어 가격이 굉장히 고가여서 상업용으로만 이용됐지만 저렴해진 컴퓨터의 가격으로 개인이 소유하기 쉬워졌다.
    - 이 때는 애플의 매킨토시와 마이크로소프트의 MS-DOS가 많이 사용됐다. 당시 매킨토시는 GUI를 도입해서 굉장한 인기를 얻었었다.

## 운영체제의 구조
운영체제의 핵심은 커널입니다. 커널은 프로세스와 메모리, 저장장치를 관리하는 핵심적인 기능을 담당하고 있습니다. 사용자는 운영체제의 커널에 직접 접근할 수 없고 인터페이스를 통해서 접근할 수 있다.

인터페이스는 GUI와 CLI 두개로 나눌 수 있는데 텍스트냐 그림이냐 차이만 있을 뿐 커널에 접근하기 위한 목적은 같습니다.

### GUI
GUI는 Graphic User Interface의 약자로 말 그대로 그래픽으로 된 인터페이스입니다. Windows나 Mac OS와 같이 그래픽으로 커널과 상호작용 하기 때문에 일반 사용자도 사용하기가 쉽습니다.

### CLI
CLI는 Command Line Interface의 약자입니다. 유닉스나 리눅스 같은 운영체제가 기본적으로 제공하는 인터페이스로 텍스트를 이용해 커널과 상호 작용합니다. 요즘은 리눅스에도 GUI 환경을 제공하지만 많은 사용자들이 리눅스의 CLI를 선호합니다. 이를 위해 단축키로 손쉽게 CLI와 GUI모드를 변경할 수 있는 기능이 있습니다.

디렉토리를 이동하는 방식으로 간단한 차이점을 알아보자, GUI에서는 디렉토리를 더블클릭하면 손쉽게 이동할 수 있다. 반면 CLI는 cd라는 명령어를 직접 입력해야 이동 가능하다. 어플리케이션은 **시스템 콜**을 통해서 커널에 접근할 수 있다.

커널은 사용자로부터 자신을 보호하기 위한 **시스템 콜**이라는 인터페이스를 가지고 있습니다. 사용자나 어플리케이션이 하드디스크에 데이터를 저장한다고 가정해보자. 시스템 콜이 없이 어플리케이션이 하드디스크에 직접 접근하면 중요한 데이터를 덮어 쓸 수 도 있고 해당 사용자나 어플리케이션이 저장한 데이터를 다른 어플리케이션이 덮어 쓸 수도 있습니다. 시스템 콜을 이용하면 커널에서 제공하는 `Write` 함수를 쓰게 되는데 그럼 운영체제가 알아서 하드디스크의 빈 공간에 저장하게 됩니다. (더 자세한 내용은 나중에 시스템 프로그래밍을 공부하도록 하자)

사용자와 어플리케이션은 커널과의 인터페이스로 시스템 콜을 사용한다고 했는데 하드웨어와 커널의 인터페이스로는 드라이버를 사용합니다. 운영체제는 많은 종류의 하드웨어를 전부 지원해야 하기 때문에 각각의 하드웨어에 맞는 프로그램을 커널이 미리 전부 가지고 있기는 힘듭니다. 그래서 하드웨어를 제작한 제조사에서 드라이버를 만들어 제공하는게 일반적입니다. 보통 키보드나 마우스 같은 간단한 장치들은 커널에 포함되어 있어 컴퓨터에 꽂으면 바로 동작하지만 그래픽카드나 타블렛 같은 복잡한 장치들은 디바이스 드라이버를 설치해서 사용해야 합니다.

## 컴퓨터 하드웨어와 구조
오늘날 대부분의 컴퓨터는 프로그램 내장 방식의 **폰 노이만 구조**를 하고 있습니다. (폰 노이만이라는 수학자가 고안해서 폰 노이만 구조라고 부른다.) 예전에는 애니악과 같이 하드웨어로 프로그램을 만들었기 때문에 프로그램이 달라질 때 마다 매번 스위치와 배선을 다시 조정해야 했습니다. 폰 노이만은 이를 해결하기 위해 CPU와 메모리를 두고 이들 사이는 버스로 연결한다. (버스는 데이터를 전달하는 통로를 말한다.)

프로그램은 메모리에 올려서 실행시키는데 프로그램을 메모리에 내장했다고 해서 프로그램 내장방식이라고 한다. 메모리에 올라간 프로그램은 명령에 따라 처리되고 배선을 바꾸는 대신 소프트웨어만 바꿔주면 되기 때문에 상당히 편해졌다.

그러면 오늘날 컴퓨터 하드웨어를 살펴보도록 하겠다.

- 메인보드
    - 가장 기본이 되는 것은 메인보드
    - 메인보드는 다른 하드웨어를 연결하는 장치
    - 장치 간에 데이터를 전송하는 건 메인보드의 버스가 담당한다.
    - 폰 노이만 구조니까 CPU와 메모리가 필수적이다.

- CPU 구조
    - CPU는 Central Processing Unit의 약자로 중앙처리장치라고 불린다.
    - CPU를 구성하는 장치는 세 가지로 나뉜다.
        - 산술논리 연산장치
            - CPU에서 실제로 데이터 연산을 담당하는 것이 산술논리 연산장치이다
        - 제어 장치
            - 제어 장치는 모든 장치들의 동작을 지시하고 제어하는 장치입니다.
        - 레지스터
            - 레지스터는 CPU내에서 계산을 위해 임시로 보관하는 장치입니다. 즉 변수라고 생각하면 된다.
- 메모리 종류
    - 메모리는 크게 RAM과 ROM으로 구별할 수 있다.
    - RAM은 랜덤으로 데이터를 읽어도 저장된 위치와 상관 없이 읽는 속도가 같다.
    - RAM은 전력이 끊기면 데이터를 잃어버리기 때문에 메인 메모리로 사용된다.
    - ROM은 전력이 끊겨도 데이터를 계속 보관할 수 있지만 데이터를 한 번 쓰면 수정이 불가능하다.
        - 그래서 ROM은 컴퓨터의 부팅과 관련된 바이오스를 저장하는 데에 주로 쓰인다.

## 컴퓨터의 부팅과정
컴퓨터를 켰을 때 일어나는 과정을 살펴보도록 하자.

먼저 전원을 누르면 ROM에 저장된 바이오스가 실행된다. BIOS는 전원, CPU, 메모리, 키보드, 마우스, 하드디스크 등 주요 하드웨어에 이상이 없는지 체크한다. 만약 주요 장치에 이상이 있다면 오류음을 내면서 부팅이 이뤄지지 않고 이상이 없다면 하드디스크에 있는 마스터 부트 레코드에 저장된 부트로더를 메모리로 가져와서 실행한다.

만약 윈도우즈 운영체제와 리눅스 운영체제가 둘 다 설치되어 있는 컴퓨터라면 어떤 운영체제를 실행할지 선택하는 화면이 나온다. 운영체제를 선택했거나 운영체제가 하나면 바로 운영체제를 메모리로 불러오고 모니터에 바탕화면이 보이게 된다. 이제부터 실행되는 모든 응용 프로그램은 
메모리에 올라와서 운영체제가 관리한다.

## 인터럽트
CPU가 입출력 장치에 데이터를 읽거나 쓰려고 하는 상황을 생각해 보자.
CPU는 입출력 작업이 들어오면 입출력 관리자에게 입출력 명령을 내린다. CPU관점에서는 입출력 명령이 언제 완료될지 알 수 없기 때문에 주기적으로 계속 확인해줘야한다. 이러한 방식을 폴링(Polling) 방식이라고 한다. 폴링 방식의 단점은 주기적으로 CPU가 확인해줘야 하니 성능이 좋지 않다는 것입니다. 인터럽트는 폴링 방식의 단점을 해결한 방식입니다.

CPU가 입출력 관리자에게 입출력 명령을 내리고 자기는 다른 작업을 계속합니다. 입출력 관리자는 입출력이 완료됐을 때 CPU에게 신호를 주고 CPU는 그 신호를 받아 인터럽트 서비스 루틴(ISR)을 실행시켜 작업을 완료합니다.

인터럽트 서비스 루틴은 특정 인터럽트가 들어오면 그 인터럽트를 처리하는 함수입니다. 인터럽트는 비동기적으로 동작하기 때문에 성능에 이점이 있다. 인터럽트는 하드웨어 방식과 소프트웨어 방식 두 개가 있다.

- 하드웨어 방식
    - 입출력 등과 같은 인터럽트가 있고
- 소프트웨어 방식
    - 사용자 프로그램에서 발생한 인터럽트가 있다. 
    - 예를 들면 유효하지 않은 메모리에 접근하거나 0으로 나누는 명령어 등이 있다.