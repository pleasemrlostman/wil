# 프로세스 동기화

## 프로세스 간 통신
프로세스는 독립적으로 실행되기도 하지만 다른 프로세스와 데이터를 주고받으며 통신을 하는 경우도 있다.<br>
통신은 한 컴퓨터내에서 실행되고있는 다른 프로세스와 할 수도 있고 네트워크로 연결된 다른 컴퓨터에 있는 프로세스와 할 수도 있다.<br>

그러면 프로세스 간 통신의 종류를 알아보도록하자

- 파일과 파이프 사용 (한 컴퓨터 내에서 프로세스 간 통신을 하는 방법)
    - 파일 
        - 통신을 하려는 프로세스들이 하나의 파일을 이용해 읽고 쓰는 방법
    - 파이프
        - 파이프를 이용하는 방법은 운영체제가 생성한 파이프를 이용해 데이터를 읽고 쓰는 방법
- 쓰레드 이용
    - 한 프로세스 내에서 쓰레드 간 통신을 하는 방법
    - 쓰레드는 코드, 데이터, 힙 영역을 공유하고 스택만 각자 자기의 것을 가지고 있다.
    - 데이터 영역에 있는 전역변수나 힙을 이용하면 통신이 가능하다.
- 네트워크를 이용
    - 운영체제가 제공하는 소켓통신이나 다른 컴퓨터에 있는 함수를 호출하는 RPC(원격 프로시저 호출)를 이용해 통신하는 방법이 있다.

## 공유자원과 임계구역
프로세스 간 통신을 할 때 공동으로 이용하는 변수나 파일들이 있는데 이런 것들을 공유자원이라고 한다. 그러나 여기서 문제가 발생한다.<br>
공유자원은 여러 프로세스가 공유하고 있기 때문에 각 프로세스의 접근 순서에 따라 결과가 달라질 수 있다.
또한 컨텍스트 스위칭으로 시분할 처리를 하기 때문에 어떤 프로세스가 먼저 실행되고 어떤 프로세스가 나중에 실행되는지 예측하기가 힘들다<br>
따라서 연산 결과를 예측하기 힘들고 여기서 발생한 문제를 **동기화 문제**라고 부릅니다. 

게임을 예시로 들어보자, 케릭터의 총 체력이 100이고 현재 체력이 20인 상황 지금은 적에게 공격받고 있고 플레이어는 죽지 않기 위해 물약을 먹었다. 이 때 물약을 먹는 코드와 적에게 공격받는 코드에서 발생할 수 있는 동기화 문제를 살펴보자


```java
// 물약을 먹는 코드
int currentHealth = GetHealth();
health = currentHealth + 50;
// 공격받는 코드
int currentHealth = GetHealt();
health = currentHealth - 10;
```

두 가지 코드가 동시에 실행됐는데 CPU 스케줄러에 의해 공격받는 코드가 먼저 실행됐다고 가정하자 상단 코드가 실행되어 `currentHealth`에 20이 저장된다. 여기서 컨텍스트 스위칭을 하여 물약먹는 코드가 실행된다. 물약먹는 코드의 상단 코드가 실행되면서 `currentHealth` 에 20이 저장되고 세 번째 줄 코드를 실행하여 `health`를 70으로 변경합니다. 이제 다시 컨텍스트 스위칭을 하여 공격받는 코드가 실행됩니다. 
현재 공격받는 코드의 `currentHealth`에는 20이 저장돼 있는 상태라서 10을 빼주면 `health`가 10으로 변경됩니다. 결론적으로는 물약을 먹고 공격을 받아 `health`가 60이여야 하는데 10이 되어버림

결과가 이렇게 엉망이 된 이유는 `health`라는 공유자원을 여러 프로세스가 동시에 사용했기 때문이다. 따라서 여러 프로세스가 동시에 사용하면 안되는 영역을 정의햇는데 이를 **임계 구역(Critical Section)** 이라고 합니다.

공유자원을 서로 사용하기 위해 경쟁하는 것은 경쟁조건(Race Condition)이라고 합니다. 임계구역에서 발생하는 문제를 해결하기 위한 기법은 상호 배제(Mutail Exclusion) 메커니즘이 필요하다. 상호 배제 메커니즘의 요구사항은 세 가지가 있다.

- 임계영역엔 동시에 하나의 프로세스만 접근한다.
- 동시에 여러개의 요청이 있더라도 하나의 프로세스만 진입하도록 허용 해야 한다.
- 임계구역에 들어간 프로세스는 최대한 빠르게 나와야 한다. 그렇지 않으면 다른 프로세스들이 오래 기다림

## 세마포어
> 우선 예시를 통해 개념을 확인하도록 하자
> 
> 회사에서 직원들이 문서 작업을 한다. 직원들은 자기 문서의 작업을 마치면 프린터로 작업 결과물을 출력한다. 프린터는 네트워크를 통해 여러 > 컴퓨터에 연결되어 있다. 여기서 공유자원은 프린터가 된다. 
> 
> 직원 A와 직원 B가 우연히 동시에 프린터 출력을 하게 됐다. 그러면 직원 A의 컴퓨터와 직원B의 컴퓨터가 프린터를 차지하기 위해서 경쟁조건> (Race Contiotion)이 돼버립니다. 이러면 프린터의 결과물이 직원 A의 결과물과 직원 B의 결과물이 섞여서 나오기 때문에 쓸모가 없어진다.
> 
> 이런 상황을 막기 위해서 팀장님이 아이디어를 냈다. 
> 
> 프린터실을 따로 만들고 거기에 프린터와 컴퓨터를 설치해둔다. 그리고 밖에는 이 방의 열쇠를 관리하는 직원을 따로 뒀다. 
> 
> 이제 프린터를 사용하고 싶은 직원 A는 관리자에게 열쇠를 받아서 프린터실로 입장해 프린터를 혼자 사용할 수 있다. 조금 늦게 온 직원 B도 > 프린터를 사용하고 싶어서 프린터실로 들어가려고 했지만 열쇠 관리자는 이미 열쇠를 직원 A에게 준 상태라 직원 B에게 잠시 대기 하고 > 있으라고 말한다. 
> 
> 직원 A가 프린터를 다 사용하면 방에서 나오고 열쇠관리자에게 열쇠를 반납한다. 그럼 이제 직원B가 열쇠를 받고 프린터실로 들어가 프린터를 > 사용할 수 있다. 

지금 설명한 예시가 세마포어 메커니즘이다. 해당 개념은 동기화에서 가장 중요한 개념이다. 해당 예시를 운영체제에서 쓰이는 용어로 매칭 해보자

프린터를 사용하는 직원은 프로세스이고 프린터는 여러 프로세스들이 같이 공유하고 있는 **공유자원**이다 프린터를 쓰기 위해 프로세스가 기다리는 공간은 대기큐이다. 열쇠 관리자는 운영체제이다. 열쇠 관리자가 가지고 있는 열쇠는 **세마포어** 라고 한다. 세마포어는 실제로 정수형 변수이다. 

먼저 세마포어를 선언해 준다.
```java
int s = 1 // 공유변수는 health 하나이니 세마포어의 초기값을 1로 설정해준다.
// 그리고 먼저 도착한 물약먹는 코드가 실행된다.

wait(s); // 열쇠를 요청해서 열쇠를 받고 문을 자금
int currentHealth = GetHealth(); 
health = currentHealth + 50; // 체력 50증가
signal(s) // 방에서 나와 문지키는 직원에게 열쇠를


// 공격 받는 코드
// 열쇠를 받을 때 까지 대기
wait(s); // 열쇠를 요청해서 열쇠를 받고 문을 자금
int currentHealth = GetHealth(); 
health = currentHealth - 10; // 체력 10 감소
signal(s) // 방에서 나와 문지키는 직원에게 열쇠를
```

세마포어는 실제로 여러개의 열쇠를 가질 수 있다. 공유자원이 2개라면 세마포어의 값은 2

세마포어가 이렇게 보면 굉장히 좋은 동기화 방법인 것 같은데 단점이 있다

`wait()` 함수와 `signal()` 함수의 순서를 이상하게 호출해서 세마포어를 잘못 사용할 가능성이 있다는 것이다.

## 모니터

모니터는 세마포어의 단점을 해결한 상포배제 메커니즘이다.

모니터는 따로 운영체제가 처리하는 것이 아니라 프로그래밍 언어 차원에서 지원하는 방법이다.
```java
{
    private int health = 100;
    // synchronized가 붙으면 동시에 여러 프로세스에서 실행시킬 수 없다
    synchronized void increase(int amount)
    {
        health += amount;
    }
    synchronized void decrease(int amount)
    {
        health -+ amount;
    }
}
```

만약 프로세스 A에서 `increase()` 함수를 호출한다면 프로세스 B에서는 `increase()` 함수뿐만 아니라 `synchronized` 키워드가 붙은 `decrease` 함수도 실행할 수 없다.

모니터의 구현만 완벽하다면 프로그래머는 세마포어처럼 `wait()` 함수나 `signal()` 함수를 임계영역에 감싸지 않아도 돼서 편리하고 안전하게 코드를 작성 할 수 있다.