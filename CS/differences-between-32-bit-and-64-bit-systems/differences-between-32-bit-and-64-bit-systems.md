# 32비트 시스템과 64비트 시스템을 공부하며

이번에 C언어를 학습하면서 악명 높은 포인터 단원에 도달했다.

생각보다 포인터 학습은 어렵지 않았다. 그러나 나를 헷갈리게 했던 부분은 32비트와 64비트 컴퓨터 시스템의 차이였다.

대충 넘어 갈 수도 있겠지만 학습 교재에서 이 부분에 대한 학습이 미진하면 뒤에 가서 끊임없이 고통을 받는다고 하여 나름대로 해당 부분에 대해서 이해한 부분을 작성해보도록 하겠다.

우선 32비트 시스템과 64비트 시스템에 대해 간단히 알아보도록 하자 여기서 32비트와 64비트는 컴퓨터의 프로세서(CPU)가 정보를 처리하는 방식이다.

그런데 이렇게 작성하면 쉽게 와닿지 않는다. 조금 쉽게 설명하면 CPU가 처리할 수 있는 데이터의 양이라고 생각하면 편하다. 하지만 이 또한 본인은 학습 능력이 미진하여 쉽게 이해되지 않기 때문에 32비트를 예로 들어보며 이해해보도록 하자.

우선 아까 말한대로 32비트란 CPU가 처리할 수 있는 데이터의 양이라고 했다. 하지만 이 말은 정확히 말하면 틀렸다고 볼 수 있다 32비트는 CPU가 처리할 수 있는 데이터 주소의 갯수라고 보는게 조금 더 정확하다.

해당 개념을 이해하기 위해 메모리의 각 영역을 물리적으로 나눌 수 있다고 생각해보자 그리고 메모리의 물리적으로 나뉜 데이터의 단위 영역은 1byte이다. (이건 내가 임의로 정한게 아니라 오래전 아스키코드같은 거 때문에 약속된 단위임) 그렇다면 특정한 메모리를 이렇게 표현할 수 있다

| 메모리주소 (2진수)                      | 메모리주소 (16진수) | 메모리 값 (1byte = 8bit) | 메모리 값(16진수) |
| --------------------------------------- | ------------------- | ------------------------ | ----------------- |
| 0000 0000 0000 0000 0000 0000 0000 0000 | 0x00000000          | 0000 0000                | 00                |
| 0000 0000 0000 0000 0000 0000 0000 0001 | 0x00000001          | 0000 0000                | 00                |
| 0000 0000 0000 0000 0000 0000 0000 0010 | 0x00000002          | 0000 0000                | 00                |
| 0000 0000 0000 0000 0000 0000 0000 0011 | 0x00000003          | 0000 0000                | 00                |
| 0000 0000 0000 0000 0000 0000 0000 0100 | 0x00000004          | 0000 0000                | 00                |
| …..                                     |                     |                          |                   |
| 1111 1111 1111 1111 1111 1111 1111 1101 | FFFFFFFD            | 0000 0000                | 00                |
| 1111 1111 1111 1111 1111 1111 1111 1110 | FFFFFFFE            | 0000 0000                | 00                |
| 1111 1111 1111 1111 1111 1111 1111 1111 | FFFFFFFF            | 0000 0000                | 00                |

32비트는

0000 0000 0000 0000 0000 0000 0000 0000 주소 값부터 시작해서

1111 1111 1111 1111 1111 1111 1111 1111 주소 값으로 끝난다

해당 주소 값의 갯수를 확인해보면 2^32 즉 4,294,967,296개의 고유한 주소를 가진다.

<aside>
💡 여기서 내가 학습하며 헷갈린 부분은 메모리 주소와 메모리 값을 구분해야 했는데 이 부분을 조금 헷갈려했다.

</aside>

자 그런데 위의 표를 확인해보자 각 주소들은 모두 1byte의 값을 가진다고 하지 않았나? 그런데 32비트에서는 총 4,294,967,296개의 주소가 있지 않는가 그렇다는 말은 4,294,967,296byte의 값을 가지고 있다 해당 4,294,967,296byte를 우리가 잘 아는 gb값으로 변경해보자 그러면 놀랍게도 4GB가 나온다. 그러므로 32비트는 메모리의 최대 값을 4GB밖에 못 가진다 그러다 보니까 아무리 더 많은 메모리를 꽂아도 4,294,967,296번 이후의 주소 값을 가질 수 없다는 말이 된다.

<aside>
💡 여기서 내가 헷갈린건 4,294,967,296라는 값은 단순히 갯수라고 생각을 했어야 했는데 그렇지 못 한거다 즉 여기서 4,294,967,296는 어떤 단위가 아니라 그냥 순전히 갯수다.

그 말은 4,294,967,296 값은 2^32 갯수이고 이걸 바이트로 보냐 비트로 보냐 차이밖에 안된다.

만약에 단위를 바이트로 한다면 2^32 x 1 이다 그 말은 2^32 바이트 = 4gb가 되는 것이다

그런데 이걸 비트로 계산한다? 그러면 2^32 x 2^3(8) 이다 왜냐고? 1바이트는 8비트이기때문

그래서 결국 2^35비트가 되고 그 값은 34,359,738,368비트다.

34,359,738,368비트도 gb로 표현하면? 4gb가 나온다.

</aside>

자 그러면 내가 아무리 멍청하지만 32비트로 이해했으니 64비트는 빠르게 작성하고 넘어가보도록 하자 64비트 결국 2^64개의 데이터주소를 가진다 그러므로 2^64byte이므로 이를 gb로 표현하면 17,179,869,184gb이고 이는 1,073,741,824개 즉 대략적으로 10억개의 16gb를 사용할 수 있다는 말이다. 사용할 수 있는 메모리 용량이 4gb인 32비트 컴퓨터에 비교하면 64비트는 말도안되는 양의 메모리를 사용할 수 있는 것 이다.

그러면 이제 실제로 내가 헷갈린 부분을 보도록하자

c언어에서 임의로 아래의 코드를 작성했다고 하자.

```c
main
{
	int a = 10;
	int* pA = &a;
}
```

해당 코드를 분석해보자 나는 int a라는 변수를 선언했고 10이란 정수로 초기화했다.

그리고 int 포인터 pA를 선언했고 해당 값에 a의 포인터주소 값으로 초기화했다.

이제 이 과정을 메모리 영역을 보면서 살펴보자 그런데 학습의 편의성을 위해 내가 선언한 변수가 운 좋게도 메모리의 가장 첫 번째 위치부터 시작했다고 보자.

| 메모리주소 (2진수)                      | 메모리주소 (16진수) | 메모리 값 (1byte = 8bit) | 메모리 값(16진수) |
| --------------------------------------- | ------------------- | ------------------------ | ----------------- |
| 0000 0000 0000 0000 0000 0000 0000 0000 | 0x00000000          | 0000 0000                | 00                |
| 0000 0000 0000 0000 0000 0000 0000 0001 | 0x00000001          | 0000 0000                | 00                |
| 0000 0000 0000 0000 0000 0000 0000 0010 | 0x00000002          | 0000 0000                | 00                |
| 0000 0000 0000 0000 0000 0000 0000 0011 | 0x00000003          | 0000 1010                | 0A                |

나는 4비트의 int를 선언했다 그러므로 a변수는 4비트 만큼의 메모리 영역을 차지할 것이다. 그러므로 메모리에서 위의 테이블 주소 갯수 만큼 영역을 잡을 것이다.

자 그런데 나는 10으로 초기화했다 10을 2진수로 변경하면 1010이다 그러므로 메모리 값에는 위의 표처럼 0x00000003 메모리 주소에 0000 1010이란 값이 들어갈거라고 예상 할 수 있다. 왜냐면 실제 정수 10은 2진수로 표현하면 1010이지만 4비트 만큼의 데이터 영역을 전부 사용하기 때문에 실제 값은 0000 0000 0000 0000 0000 0000 0000 1010(2)가 될 거고 너무 기니까 16진수로 표현하면

0x0000000A가 된다.

하지만 실제로 저장되는 값은 아래의 데이터 처럼 저장된다.

| 메모리주소 (2진수)                      | 메모리주소 (16진수) | 메모리 값 (1byte = 8bit) | 메모리 값(16진수) |
| --------------------------------------- | ------------------- | ------------------------ | ----------------- |
| 0000 0000 0000 0000 0000 0000 0000 0000 | 0x00000000          | 0000 1010                | 0A                |
| 0000 0000 0000 0000 0000 0000 0000 0001 | 0x00000001          | 0000 0000                | 00                |
| 0000 0000 0000 0000 0000 0000 0000 0010 | 0x00000002          | 0000 0000                | 00                |
| 0000 0000 0000 0000 0000 0000 0000 0011 | 0x00000003          | 0000 1010                | 00                |

본인이 생각하기에 이렇게 되면 0A000000 이렇게 읽기 때문에 정수 10이 아니라 정수 167772160이 나온다. 하지만 여기서 본인이 몰랐던 개념이 있는데 그 개념은 바로

빅 엔디안과 리틀 엔디안이란 개념이다.

보통의 데이터는 낮은 주소에서 높은 주소로 차례로 저장되지만

이 데이터가 저장되는 순서에 따라 빅 엔디안과 리틀 엔디안으로 나뉜다.

빅 엔디안은 상위 비트부터 바이트 단위로 저장하는 방식으로 평소 사람이 숫자를 사용하는 방식과 같다. 큰 자리 수부터 저장하기 때문에 숫자 비교에 유리하고 읽기고 이해하기도 용이하다.

리틀 엔디안은 하위 비트부터 바이트 단위로 저장하는 방식이다.

이유는 잘 모르겠지만 보통 컴퓨터에서는 리틀 엔디안 방식을 사용하고 네트워크 통신을 할 때는 빅 엔디안 방식을 사용한다고 한다.

본인의 이번 주요 학습 목표는 포인터이기 때문에 이 정도만 이해하려고 넘어가려고 한다. 하지만 다음에 기회가 생긴다면 각각 엔디안의 특징을 학습해보도록 하겠다.
