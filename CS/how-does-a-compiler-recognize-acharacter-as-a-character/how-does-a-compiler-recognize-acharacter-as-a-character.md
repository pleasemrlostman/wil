# 컴파일러는 어떻게 문자를 문자로서 인식할까?

# 1. 의문의 시작

C언어를 공부하면서 문자를 표현하는 방법 중 하나인 아스키코드에 대해서 학습했다.

사실 아스키 코드자체는 어려운게 없다. 각 문자마다 그에 해당하는 2진수 코드를 부여하고 컴파일러가 이를 해석 할 때 해당 코드에 일치하는 문자를 클라이언트에게 보여주면된다. 실제로도 해당 코드는 매우 간단하다 아래 코드를 살펴보자

```c
int main(void) {
    char ch1 = 'A'; // 작은따옴표
    char ch2 = 'B'; // 작은따옴표
    return 0;
}
```

이렇게 작성하면 ch1은 A를 ch2는 B를 보여줄 것이다.

하지만 여기서 나는 의문이 들었다 문자 A를 아스키코드로 살펴보면 10진수 065 문자 B는 066이다. 이를 이진수로 표현하면 1000001이고 B는 1000010이다. 이를 간단하게 16진수로 살펴보면 각각 0x41, 0x42임을 확인할 수 있다.

하지만 도대체 무엇이 0x41과 0x42 값을 문자로 인식하게 만드냔말이다? 혹시 해당 코드가 어셈블리어로 변환되면 어떤 키워드가 있는건가? 싶어서 GPT의 힘을 빌려 해당 코드를 어셈블리어로 변환해봤다.

```nasm
section .data
    ch1 db 'A'  ; 'A'를 저장
    ch2 db 'B'  ; 'B'를 저장

section .text
    global _start

_start:
    ; main 함수 시작 (여기서는 단순히 반환)
    mov eax, 1  ; syscall: exit
    xor ebx, ebx ; return 0
    int 0x80
```

하지만 해당 코드는 그저 C언어의 문법을 어셈블리어로 변경했을 뿐 해당 코드에서 명시적으로 A와 B를 적어주고있다. 그렇다면 어디에서 메모리에 저장된 0x41이란 값과 0x42란 값을 문자로 인식하는 것 일까?

# 2. 상징 테이블

### 상징테이블이란?

상징 테이블은 컴파일러와 링커가 사용하는 데이터 구조로, 프로그램 내에서 사용되는 식별자(변수 및 함수 이름 등)의 목록, 타입, 범위(가시성), 메모리 위치 등 각 식별자에 관한 정보를 포함하고 있다. 이 테이블은 프로그램 전반에 걸쳐 이러한 식별자에 대한 참조를 해결하는 데 중요한 역할을 한다.

컴파일러는 컴파일하는 과정에서 상징 테이블이란 테이블을 생성한다. 이 테이블에는 변수의 이름, 타입, 메모리 주소, 스코프(변수의 유효 범위) 등의 정보가 포함된다.

만약에 char ch1 이라는 변수가 선언되면, 상징 테이블에는 아래와 같은 정보가 저장 될 수 있다.

- 변수 이름: `ch1`
- 타입: `char`
- 주소: (변수가 메모리의 특정 주소를 차지하게 됨)
- 스코프: (예: 이 변수가 정의된 블록의 범위)

그러므로 해당 코드의 상징테이블은

이 코드를 컴파일할 때, 상징 테이블은 다음과 같이 작성된다.

| 변수 이름 | 데이터 타입 | 메모리 주소 | 크기 |
| --------- | ----------- | ----------- | ---- |
| ch1       | char        | 0x1000      | 1    |
| ch2       | char        | 0x1001      | 1    |

즉 해당 상징테이블에서 해당 변수의 타입을 저장하기 때문에 `ch1` 에 할당된 0x41이란 값을 문자 A로 인식 할 수 있다.

# 3. 코드의 변환 과정

## 0. 작성 이유

사실 위의 상징 테이블을 통해서 내가 궁금했던 의문은 전부 해결했다. 하지만 비록 100% 이해하지 해당 과정이 내부적으로 어떻게 진행되는지 살펴보며 어떻게 해당 코드를 문자로 인식하는지 살펴보도록 하자

## 1. 진행 과정

### 1. 상징 테이블 작성

```c
int main(void) {
    char ch1 = 'A'; // 작은따옴표
    char ch2 = 'B'; // 작은따옴표
    return 0;
}
```

이 코드를 컴파일할 때, 상징 테이블은 다음과 같이 작성된다.

| 변수 이름 | 데이터 타입 | 메모리 주소 | 크기 |
| --------- | ----------- | ----------- | ---- |
| ch1       | char        | 0x1000      | 1    |
| ch2       | char        | 0x1001      | 1    |

- `ch1`과 `ch2`는 각각 `char` 타입 변수로, 메모리에서 1바이트를 차지한다.
- 이 변수들은 함수의 스택 프레임 내에서 할당되며, 주소는 예시로 제공된다.

### 2. 중간 코드 생성

컴파일러는 위와 같은 상징 테이블을 작성하고 C 코드를 중간 코드로 변환한다.

```arduino
1. allocate 1 byte for ch1
2. ch1 = 'A'
3. allocate 1 byte for ch2
4. ch2 = 'B'
5. return 0
```

### 3. 어셈블리어 코드 생서

이후 중간 코드는 어셈블리어 코드로 변환된다.

```nasm
section .bss
    ch1 resb 1          ; ch1을 위한 1바이트 공간 예약
    ch2 resb 1          ; ch2를 위한 1바이트 공간 예약

section .text
    global main

main:
    mov byte [ch1], 'A' ; ch1에 'A' 저장
    mov byte [ch2], 'B' ; ch2에 'B' 저장
    mov eax, 0          ; return 0
    ret
```

### 4. 기계어 코드 생성

최종적으로 어셈블리 코드는 기계어 코드로 변환된다. 기계어는 CPU가 직접 이해하고 실행할 수 있는 0과 1로 이루어진 코드이다.

```nasm
B8 00 00 00 00        ; mov eax, 0
C3                   ; ret
```

## 2. 요약

- **상징 테이블**: 변수의 이름, 타입, 메모리 주소 및 크기가 저장된다.
- **중간 코드**: 변수의 메모리 할당 및 초기화에 대한 명세를 포함된다.
- **어셈블리어**: 중간 코드가 CPU 아키텍처에 맞는 어셈블리어로 변환된다.
- **기계어**: 어셈블리어는 최종적으로 기계어로 변환되어 실행 가능한 파일에 포함된다.

## 3. 의문점

그런데 내가 궁금한 점은 기계어 코드 부분이다. 분명 컴퓨터가 어떤 명령을 시키는 건 기계어로 이루어 진다고 들었는데 해당 기계어에는 변수를 선언하고 할당하는 부분이 생략되어있다. 그래서 해당 코드를 GPT에게 분석하라고 했는데 아래와 같은 대답을 들었다.

### 기계어 코드 분석

1. **`B8 00 00 00 00`**
   - **B8**: 이 바이트는 `mov eax, imm32` 명령을 나타냅니다. `B8`는 `EAX` 레지스터에 32비트 즉시 값(immediate value)을 로드하는 명령의 오퍼코드입니다.
   - **`00 00 00 00`**: 이 4바이트는 즉시 값, 즉 `0`을 나타냅니다. 따라서 이 명령은 `EAX` 레지스터에 `0`을 저장하라는 뜻입니다.
   - 전체 명령은 "EAX 레지스터에 0을 이동시킨다"로 해석됩니다.
2. **`C3`**
   - 이 바이트는 `ret` 명령을 나타냅니다. `ret`는 현재 함수의 실행을 종료하고, 호출한 지점으로 제어를 반환하라는 뜻입니다.
   - 따라서, 이 명령은 메인 함수에서 `return 0;`의 역할을 합니다.

### 요약

- **`B8 00 00 00 00`**: `mov eax, 0` — `EAX` 레지스터에 `0`을 저장.
- **`C3`**: `ret` — 현재 함수(여기서는 `main`)를 종료하고 호출한 지점으로 반환.

이 두 명령은 함께 실행되어 메인 함수의 끝에서 `0`을 반환하고 프로그램을 정상 종료하는 역할을 합니다. 만약 다른 궁금한 점이나 더 깊이 있는 질문이 있다면 언제든지 말씀해 주세요!

물론 이 코드를 내가 현재 100% 이해하는 건 아니지만 해당 부분에서 변수를 초기화하는 부분이 없다는 것 만큼은 알 수 있다. 그래서 어떻게 된 건지 또 GPT에게 물어보니 이러한 답변을 들었다.

💡

> 기계어 코드에 변수를 선언하거나 할당하는 부분이 명시적으로 보이지 않는 이유는, 이러한 작업이 이전 단계에서 이미 처리되었기 때문입니다. C 코드에서 변수를 선언하고 초기화하는 과정은 컴파일러가 변환하는 여러 단계에서 이루어집니다.

즉 결론을 말하면 어셈블리 코드를 생성하는 과정에서 메모리 주소와 데이터 배치가 결정된다. 조금 더 자세하게 말하면 컴퓨터는 기계어만 이해하지만, 컴파일러는 고급 언어를 기계어로 변환하는 복잡한 과정을 통해 변수 초기화와 같은 작업을 처리한다고 볼 수 있다.

하지만 이 부분이 아직 100% 이해는 되지 않는다. 그러나 다음 학습을 위해 이 정도로 마무리 지어보도록 하겠다.
