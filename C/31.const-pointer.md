## 1. const 키워드와 상수화

const 키워드는 변수 앞에 선언하여 해당 변수를 상수로 만든다. 상수로 선언된 변수는 값을 변경할 수 없다. 예를 들어, 다음과 같은 코드가 있다:

```c

const int i = 100;
```

여기서 i는 상수로 선언되었기 때문에 프로그램 내에서 i = 200;처럼 값을 변경하려고 하면 컴파일 오류가 발생한다. 즉, i는 한 번 초기화되면 값을 변경할 수 없는 상수가 된다.

## 2. const와 포인터의 상호작용

포인터와 const를 함께 사용할 때, 여러 가지 상수화 규칙이 적용된다.

### 2-1. 포인터 없이 일반 변수의 경우

포인터 없이 int 변수를 선언하고 이를 수정할 수 있다:

```c

int a = 0;
int* pInt = &a;  // 포인터 pInt는 a의 주소를 가리킴

*pInt = 1;  // a의 값을 1로 변경 가능
pInt = NULL;  // 포인터 pInt가 다른 주소값을 가리킬 수 있음
```

이 코드에서는 포인터가 가리키는 대상(a)의 값을 변경할 수 있고, 포인터 자체가 가리키는 주소도 변경할 수 있다.

### 2-2. 가리키는 대상이 상수인 경우 (const int\*)

포인터가 가리키는 대상이 상수로 선언된 경우, 그 값을 변경할 수 없다. 하지만 포인터 자체는 다른 주소를 가리킬 수 있다:

```c

const int* pConstInt = &a;
*pConstInt = 100;  // 컴파일 오류: 가리키는 대상의 값 변경 불가
```

위 코드에서는 pConstInt가 가리키는 a의 값을 수정할 수 없다. 그러나 포인터 자체는 다른 변수의 주소를 가리킬 수 있다:

```c

int b = 0;
pConstInt = &b;  // 포인터는 다른 주소값을 가리킬 수 있음
```

### 2-3. 포인터 자체가 상수인 경우 (int\* const)

포인터 자체가 상수로 선언된 경우, 포인터가 가리키는 주소는 변경할 수 없지만, 가리키는 값은 변경할 수 있다:

```c

int* const pIntConst = &a;
*pIntConst = 400;  // 가리키는 대상(a)의 값은 변경 가능
pIntConst = &b;  // 컴파일 오류: 포인터 자체는 다른 주소값을 가리킬 수 없음
```

위 코드에서는 포인터가 가리키는 대상의 값을 바꿀 수 있지만, 포인터가 다른 주소를 가리키도록 변경하는 것은 불가능하다.

### 2-4. 포인터와 가리키는 대상 모두 상수인 경우 (const int\* const)

포인터가 가리키는 대상과 포인터 자체 모두 상수로 선언된 경우, 포인터가 가리키는 값을 변경할 수도 없고, 포인터 자체가 다른 주소를 가리키게 할 수도 없다:

```c

const int* const pConstIntConst = &a;
*pConstIntConst = 500;  // 컴파일 오류: 가리키는 대상의 값 변경 불가
pConstIntConst = &b;    // 컴파일 오류: 포인터 자체가 다른 주소값을 가리킬 수 없음
```

## 3. 포인터와 상수화의 요약

포인터와 const의 조합은 다양한 상황에서 다르게 동작한다:

- const int\* p는 가리키는 값을 변경할 수 없지만, 포인터 자체는 다른 주소를 가리킬 수 있다.
- int\* const p는 포인터 자체가 다른 주소를 가리킬 수 없지만, 가리키는 값은 변경할 수 있다.
- const int\* const p는 포인터가 가리키는 값도, 포인터 자체도 변경할 수 없다.
